// Code generated by go generate; DO NOT EDIT.

package static // import "miniflux.app/ui/static"

var Javascripts = map[string]string{
	"app": `(function(){'use strict';class DomHelper {
    static isVisible(element) {
        return element.offsetParent !== null;
    }

    static openNewTab(url) {
        let win = window.open("");
        win.opener = null;
        win.location = url;
        win.focus();
    }

    static scrollPageTo(element) {
        let windowScrollPosition = window.pageYOffset;
        let windowHeight = document.documentElement.clientHeight;
        let viewportPosition = windowScrollPosition + windowHeight;
        let itemBottomPosition = element.offsetTop + element.offsetHeight;

        if (viewportPosition - itemBottomPosition < 0 || viewportPosition - element.offsetTop > windowHeight) {
            window.scrollTo(0, element.offsetTop - 10);
        }
    }

    static getVisibleElements(selector) {
        let elements = document.querySelectorAll(selector);
        let result = [];

        for (let i = 0; i < elements.length; i++) {
            if (this.isVisible(elements[i])) {
                result.push(elements[i]);
            }
        }

        return result;
    }

    static findParent(element, selector) {
        for (; element && element !== document; element = element.parentNode) {
            if (element.classList.contains(selector)) {
                return element;
            }
        }

        return null;
    }

    static hasPassiveEventListenerOption() {
        var passiveSupported = false;

        try {
            var options = Object.defineProperty({}, "passive", {
                get: function() {
                    passiveSupported = true;
                }
            });

            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
        } catch(err) {
            passiveSupported = false;
        }

        return passiveSupported;
    }
}
class TouchHandler {
    constructor() {
        this.reset();
    }

    reset() {
        this.touch = {
            start: { x: -1, y: -1 },
            move: { x: -1, y: -1 },
            element: null
        };
    }

    calculateDistance() {
        if (this.touch.start.x >= -1 && this.touch.move.x >= -1) {
            let horizontalDistance = Math.abs(this.touch.move.x - this.touch.start.x);
            let verticalDistance = Math.abs(this.touch.move.y - this.touch.start.y);

            if (horizontalDistance > 30 && verticalDistance < 70) {
                return this.touch.move.x - this.touch.start.x;
            }
        }

        return 0;
    }

    findElement(element) {
        if (element.classList.contains("touch-item")) {
            return element;
        }

        return DomHelper.findParent(element, "touch-item");
    }

    onTouchStart(event) {
        if (event.touches === undefined || event.touches.length !== 1) {
            return;
        }

        this.reset();
        this.touch.start.x = event.touches[0].clientX;
        this.touch.start.y = event.touches[0].clientY;
        this.touch.element = this.findElement(event.touches[0].target);
    }

    onTouchMove(event) {
        if (event.touches === undefined || event.touches.length !== 1 || this.element === null) {
            return;
        }

        this.touch.move.x = event.touches[0].clientX;
        this.touch.move.y = event.touches[0].clientY;

        let distance = this.calculateDistance();
        let absDistance = Math.abs(distance);

        if (absDistance > 0) {
            let opacity = 1 - (absDistance > 75 ? 0.9 : absDistance / 75 * 0.9);
            let tx = distance > 75 ? 75 : (distance < -75 ? -75 : distance);

            this.touch.element.style.opacity = opacity;
            this.touch.element.style.transform = "translateX(" + tx + "px)";

            event.preventDefault();
        }
    }

    onTouchEnd(event) {
        if (event.touches === undefined) {
            return;
        }

        if (this.touch.element !== null) {
            let distance = Math.abs(this.calculateDistance());

            if (distance > 75) {
                toggleEntryStatus(this.touch.element);
            }

            this.touch.element.style.opacity = 1;
            this.touch.element.style.transform = "none";
        }

        this.reset();
    }

    listen() {
        let elements = document.querySelectorAll(".touch-item");
        let hasPassiveOption = DomHelper.hasPassiveEventListenerOption();

        elements.forEach((element) => {
            element.addEventListener("touchstart", (e) => this.onTouchStart(e), hasPassiveOption ? { passive: true } : false);
            element.addEventListener("touchmove", (e) => this.onTouchMove(e), hasPassiveOption ? { passive: false } : false);
            element.addEventListener("touchend", (e) => this.onTouchEnd(e), hasPassiveOption ? { passive: true } : false);
            element.addEventListener("touchcancel", () => this.reset(), hasPassiveOption ? { passive: true } : false);
        });

        let entryContentElement = document.querySelector(".entry-content");
        if (entryContentElement) {
            let doubleTapTimers = {
                previous: null,
                next: null
            };

            const detectDoubleTap = (doubleTapTimer, event) => {
                const timer = doubleTapTimers[doubleTapTimer];
                if (timer === null) {
                    doubleTapTimers[doubleTapTimer] = setTimeout(() => {
                        doubleTapTimers[doubleTapTimer] = null;
                    }, 200);
                } else {
                    event.preventDefault();
                    goToPage(doubleTapTimer);
                }
            };

            entryContentElement.addEventListener("touchend", (e) => {
                if (e.changedTouches[0].clientX >= (entryContentElement.offsetWidth / 2)) {
                    detectDoubleTap("next", e);
                } else {
                    detectDoubleTap("previous", e);
                }
            }, hasPassiveOption ? { passive: false } : false);

            entryContentElement.addEventListener("touchmove", (e) => {
                Object.keys(doubleTapTimers).forEach(timer => doubleTapTimers[timer] = null);
            });
        }
    }
}
class KeyboardHandler {
    constructor() {
        this.queue = [];
        this.shortcuts = {};
        this.triggers = [];
    }

    on(combination, callback) {
        this.shortcuts[combination] = callback;
        this.triggers.push(combination.split(" ")[0]);
    }

    listen() {
        document.onkeydown = (event) => {
            let key = this.getKey(event);
            if (this.isEventIgnored(event, key) || this.isModifierKeyDown(event)) {
                return;
            } else {
                event.preventDefault();
            }

            this.queue.push(key);

            for (let combination in this.shortcuts) {
                let keys = combination.split(" ");

                if (keys.every((value, index) => value === this.queue[index])) {
                    this.queue = [];
                    this.shortcuts[combination](event);
                    return;
                }

                if (keys.length === 1 && key === keys[0]) {
                    this.queue = [];
                    this.shortcuts[combination](event);
                    return;
                }
            }

            if (this.queue.length >= 2) {
                this.queue = [];
            }
        };
    }

    isEventIgnored(event, key) {
        return event.target.tagName === "INPUT" ||
            event.target.tagName === "TEXTAREA" ||
            (this.queue.length < 1 && !this.triggers.includes(key));

    }

    isModifierKeyDown(event) {
        return event.getModifierState("Control") || event.getModifierState("Alt") || event.getModifierState("Meta");
    }

    getKey(event) {
        const mapping = {
            'Esc': 'Escape',
            'Up': 'ArrowUp',
            'Down': 'ArrowDown',
            'Left': 'ArrowLeft',
            'Right': 'ArrowRight'
        };

        for (let key in mapping) {
            if (mapping.hasOwnProperty(key) && key === event.key) {
                return mapping[key];
            }
        }

        return event.key;
    }
}
class RequestBuilder {
    constructor(url) {
        this.callback = null;
        this.url = url;
        this.options = {
            method: "POST",
            cache: "no-cache",
            credentials: "include",
            body: null,
            headers: new Headers({
                "Content-Type": "application/json",
                "X-Csrf-Token": this.getCsrfToken()
            })
        };
    }

    withHttpMethod(method) {
        this.options.method = method;
        return this;
    }

    withBody(body) {
        this.options.body = JSON.stringify(body);
        return this;
    }

    withCallback(callback) {
        this.callback = callback;
        return this;
    }

    getCsrfToken() {
        let element = document.querySelector("meta[name=X-CSRF-Token]");
        if (element !== null) {
            return element.getAttribute("value");
        }

        return "";
    }

    execute() {
        fetch(new Request(this.url, this.options)).then((response) => {
            if (this.callback) {
                this.callback(response);
            }
        });
    }
}
class ModalHandler {
    static exists() {
        return document.getElementById("modal-container") !== null;
    }

    static open(fragment) {
        if (ModalHandler.exists()) {
            return;
        }

        let container = document.createElement("div");
        container.id = "modal-container";
        container.appendChild(document.importNode(fragment, true));
        document.body.appendChild(container);

        let closeButton = document.querySelector("a.btn-close-modal");
        if (closeButton !== null) {
            closeButton.onclick = (event) => {
                event.preventDefault();
                ModalHandler.close();
            };
        }
    }

    static close() {
        let container = document.getElementById("modal-container");
        if (container !== null) {
            container.parentNode.removeChild(container);
        }
    }
}
// OnClick attaches a listener to the elements that match the selector.
function onClick(selector, callback, noPreventDefault) {
    let elements = document.querySelectorAll(selector);
    elements.forEach((element) => {
        element.onclick = (event) => {
            if (!noPreventDefault) {
                event.preventDefault();
            }

            callback(event);
        };
    });
}

// Show and hide the main menu on mobile devices.
function toggleMainMenu() {
    let menu = document.querySelector(".header nav ul");
    if (DomHelper.isVisible(menu)) {
        menu.style.display = "none";
    } else {
        menu.style.display = "block";
    }

    let searchElement = document.querySelector(".header .search");
    if (DomHelper.isVisible(searchElement)) {
        searchElement.style.display = "none";
    } else {
        searchElement.style.display = "block";
    }
}

// Handle click events for the main menu (<li> and <a>).
function onClickMainMenuListItem(event) {
    let element = event.target;

    if (element.tagName === "A") {
        window.location.href = element.getAttribute("href");
    } else {
        window.location.href = element.querySelector("a").getAttribute("href");
    }
}

// Change the button label when the page is loading.
function handleSubmitButtons() {
    let elements = document.querySelectorAll("form");
    elements.forEach((element) => {
        element.onsubmit = () => {
            let button = element.querySelector("button");

            if (button) {
                button.innerHTML = button.dataset.labelLoading;
                button.disabled = true;
            }
        };
    });
}

// Set cursor focus to the search input.
function setFocusToSearchInput(event) {
    event.preventDefault();
    event.stopPropagation();

    let toggleSwitchElement = document.querySelector(".search-toggle-switch");
    if (toggleSwitchElement) {
        toggleSwitchElement.style.display = "none";
    }

    let searchFormElement = document.querySelector(".search-form");
    if (searchFormElement) {
        searchFormElement.style.display = "block";
    }

    let searchInputElement = document.getElementById("search-input");
    if (searchInputElement) {
        searchInputElement.focus();
        searchInputElement.value = "";
    }
}

// Show modal dialog with the list of keyboard shortcuts.
function showKeyboardShortcuts() {
    let template = document.getElementById("keyboard-shortcuts");
    if (template !== null) {
        ModalHandler.open(template.content);
    }
}

// Mark as read visible items of the current page.
function markPageAsRead() {
    let items = DomHelper.getVisibleElements(".items .item");
    let entryIDs = [];

    items.forEach((element) => {
        element.classList.add("item-status-read");
        entryIDs.push(parseInt(element.dataset.id, 10));
    });

    if (entryIDs.length > 0) {
        updateEntriesStatus(entryIDs, "read", () => {
            // Make sure the Ajax request reach the server before we reload the page.

            let element = document.querySelector("a[data-action=markPageAsRead]");
            let showOnlyUnread = false;
            if (element) {
                showOnlyUnread = element.dataset.showOnlyUnread || false;
            }

            if (showOnlyUnread) {
                window.location.reload();
            } else {
                goToPage("next", true);
            }
        });
    }
}

// Handle entry status changes from the list view and entry view.
function handleEntryStatus(element) {
    let toasting = !element;
    let currentEntry = findEntry(element);
    if (currentEntry) {
        toggleEntryStatus(currentEntry, toasting);
        if (isListView() && currentEntry.classList.contains('current-item')) {
            goToNextListItem();
        }
    }
}

// Change the entry status to the opposite value.
function toggleEntryStatus(element, toasting) {
    console.log("//TODO silently option");
    let entryID = parseInt(element.dataset.id, 10);
    let link = element.querySelector("a[data-toggle-status]");

    let currentStatus = link.dataset.value;
    let newStatus = currentStatus === "read" ? "unread" : "read";

    updateEntriesStatus([entryID], newStatus);

    if (currentStatus === "read") {
        link.innerHTML = '<span class="icon-label">' + link.dataset.labelRead + '</span>';
        link.dataset.value = "unread";
        if (toasting) {
            toast(link.dataset.toastUnread);
        }
    } else {
        link.innerHTML = '<span class="icon-label">' + link.dataset.labelUnread + '</span>';
        link.dataset.value = "read";
        if (toasting) {
            toast(link.dataset.toastRead);
        }
    }

    if (element.classList.contains("item-status-" + currentStatus)) {
        element.classList.remove("item-status-" + currentStatus);
        element.classList.add("item-status-" + newStatus);
    }
}

// Mark a single entry as read.
function markEntryAsRead(element) {
    if (element.classList.contains("item-status-unread")) {
        element.classList.remove("item-status-unread");
        element.classList.add("item-status-read");

        let entryID = parseInt(element.dataset.id, 10);
        updateEntriesStatus([entryID], "read");
    }
}

// Send the Ajax request to refresh all feeds in the background
function handleRefreshAllFeeds() {
    let url = document.body.dataset.refreshAllFeedsUrl;
    let request = new RequestBuilder(url);

    request.withCallback(() => {
        window.location.reload();
    });

    request.withHttpMethod("GET");
    request.execute();
}

// Send the Ajax request to change entries statuses.
function updateEntriesStatus(entryIDs, status, callback) {
    let url = document.body.dataset.entriesStatusUrl;
    let request = new RequestBuilder(url);
    request.withBody({entry_ids: entryIDs, status: status});
    request.withCallback(callback);
    request.execute();

    if (status === "read") {
        decrementUnreadCounter(1);
    } else {
        incrementUnreadCounter(1);
    }
}

// Handle save entry from list view and entry view.
function handleSaveEntry(element) {
    let toasting = !element;
    let currentEntry = findEntry(element);
    if (currentEntry) {
        saveEntry(currentEntry.querySelector("a[data-save-entry]"), toasting);
    }
}

// Send the Ajax request to save an entry.
function saveEntry(element, toasting) {
    if (!element) {
        return;
    }

    if (element.dataset.completed) {
        return;
    }

    let previousInnerHTML = element.innerHTML;
    element.innerHTML = '<span class="icon-label">' + element.dataset.labelLoading + '</span>';

    let request = new RequestBuilder(element.dataset.saveUrl);
    request.withCallback(() => {
        element.innerHTML = previousInnerHTML;
        element.dataset.completed = true;
        if (toasting) {
            toast(element.dataset.toastDone);
        }
    });
    request.execute();
}

// Handle bookmark from the list view and entry view.
function handleBookmark(element) {
    let toasting = !element;
    let currentEntry = findEntry(element);
    if (currentEntry) {
        toggleBookmark(currentEntry, toasting);
    }
}

// Send the Ajax request and change the icon when bookmarking an entry.
function toggleBookmark(parentElement, toasting) {
    let element = parentElement.querySelector("a[data-toggle-bookmark]");
    if (!element) {
        return;
    }

    element.innerHTML = '<span class="icon-label">' + element.dataset.labelLoading + '</span>';

    let request = new RequestBuilder(element.dataset.bookmarkUrl);
    request.withCallback(() => {
        if (element.dataset.value === "star") {
            element.innerHTML = '<span class="icon-label">' + element.dataset.labelStar + '</span>';
            element.dataset.value = "unstar";
            if (toasting) {
                toast(element.dataset.toastUnstar);
            }
        } else {
            element.innerHTML = '<span class="icon-label">' + element.dataset.labelUnstar + '</span>';
            element.dataset.value = "star";
            if (toasting) {
                toast(element.dataset.toastStar);
            }
        }
    });
    request.execute();
}

// Send the Ajax request to download the original web page.
function handleFetchOriginalContent() {
    console.log("//TODO target disapear fetchOriginalContent(event.target); ")

    if (isListView()) {
        return;
    }

    let element = document.querySelector("a[data-fetch-content-entry]");
    if (!element) {
        return;
    }

    let previousInnerHTML = element.innerHTML;
    element.innerHTML = '<span class="icon-label">' + element.dataset.labelLoading + '</span>';

    let request = new RequestBuilder(element.dataset.fetchContentUrl);
    request.withCallback((response) => {
        element.innerHTML = previousInnerHTML;

        response.json().then((data) => {
            if (data.hasOwnProperty("content")) {
                document.querySelector(".entry-content").innerHTML = data.content;
            }
        });
    });
    request.execute();
}

function openOriginalLink(openLinkInCurrentTab) {
    let entryLink = document.querySelector(".entry h1 a");
    if (entryLink !== null) {
        if (openLinkInCurrentTab) {
            window.location.href = entryLink.getAttribute("href");
        } else {
            DomHelper.openNewTab(entryLink.getAttribute("href"));
        }
        return;
    }

    let currentItemOriginalLink = document.querySelector(".current-item a[data-original-link]");
    if (currentItemOriginalLink !== null) {
        DomHelper.openNewTab(currentItemOriginalLink.getAttribute("href"));

        let currentItem = document.querySelector(".current-item");
        // If we are not on the list of starred items, move to the next item
        if (document.location.href != document.querySelector('a[data-page=starred]').href) {
            goToNextListItem();
        }
        markEntryAsRead(currentItem);
    }
}

function openCommentLink(openLinkInCurrentTab) {
    if (!isListView()) {
        let entryLink = document.querySelector("a[data-comments-link]");
        if (entryLink !== null) {
            if (openLinkInCurrentTab) {
                window.location.href = entryLink.getAttribute("href");
            } else {
                DomHelper.openNewTab(entryLink.getAttribute("href"));
            }
            return;
        }
    } else {
        let currentItemCommentsLink = document.querySelector(".current-item a[data-comments-link]");
        if (currentItemCommentsLink !== null) {
            DomHelper.openNewTab(currentItemCommentsLink.getAttribute("href"));
        }
    }
}

function openSelectedItem() {
    let currentItemLink = document.querySelector(".current-item .item-title a");
    if (currentItemLink !== null) {
        window.location.href = currentItemLink.getAttribute("href");
    }
}

function unsubscribeFromFeed() {
    let unsubscribeLinks = document.querySelectorAll("[data-action=remove-feed]");
    if (unsubscribeLinks.length === 1) {
        let unsubscribeLink = unsubscribeLinks[0];

        let request = new RequestBuilder(unsubscribeLink.dataset.url);
        request.withCallback(() => {
            if (unsubscribeLink.dataset.redirectUrl) {
                window.location.href = unsubscribeLink.dataset.redirectUrl;
            } else {
                window.location.reload();
            }
        });
        request.execute();
    }
}

/**
 * @param {string} page Page to redirect to.
 * @param {boolean} fallbackSelf Refresh actual page if the page is not found.
 */
function goToPage(page, fallbackSelf) {
    let element = document.querySelector("a[data-page=" + page + "]");

    if (element) {
        document.location.href = element.href;
    } else if (fallbackSelf) {
        window.location.reload();
    }
}

function goToPrevious() {
    if (isListView()) {
        goToPreviousListItem();
    } else {
        goToPage("previous");
    }
}

function goToNext() {
    if (isListView()) {
        goToNextListItem();
    } else {
        goToPage("next");
    }
}

function goToFeedOrFeeds() {
    if (isEntry()) {
        let feedAnchor = document.querySelector("span.entry-website a");
        if (feedAnchor !== null) {
            window.location.href = feedAnchor.href;
        }
    } else {
        goToPage('feeds');
    }
}

function goToPreviousListItem() {
    let items = DomHelper.getVisibleElements(".items .item");
    if (items.length === 0) {
        return;
    }

    if (document.querySelector(".current-item") === null) {
        items[0].classList.add("current-item");
        items[0].querySelector('.item-header a').focus();
        return;
    }

    for (let i = 0; i < items.length; i++) {
        if (items[i].classList.contains("current-item")) {
            items[i].classList.remove("current-item");

            let nextItem;
            if (i - 1 >= 0) {
                nextItem = items[i - 1];
            } else {
                nextItem = items[items.length - 1];
            }

            nextItem.classList.add("current-item");
            DomHelper.scrollPageTo(nextItem);
            nextItem.querySelector('.item-header a').focus();

            break;
        }
    }
}

function goToNextListItem() {
    let items = DomHelper.getVisibleElements(".items .item");
    if (items.length === 0) {
        return;
    }

    if (document.querySelector(".current-item") === null) {
        items[0].classList.add("current-item");
        items[0].querySelector('.item-header a').focus();
        return;
    }

    for (let i = 0; i < items.length; i++) {
        if (items[i].classList.contains("current-item")) {
            items[i].classList.remove("current-item");

            let nextItem;
            if (i + 1 < items.length) {
                nextItem = items[i + 1];
            } else {
                nextItem = items[0];
            }

            nextItem.classList.add("current-item");
            DomHelper.scrollPageTo(nextItem);
            nextItem.querySelector('.item-header a').focus();

            break;
        }
    }
}

function decrementUnreadCounter(n) {
    updateUnreadCounterValue((current) => {
        return current - n;
    });
}

function incrementUnreadCounter(n) {
    updateUnreadCounterValue((current) => {
        return current + n;
    });
}

function updateUnreadCounterValue(callback) {
    let counterElements = document.querySelectorAll("span.unread-counter");
    counterElements.forEach((element) => {
        let oldValue = parseInt(element.textContent, 10);
        element.innerHTML = callback(oldValue);
    });

    if (window.location.href.endsWith('/unread')) {
        let oldValue = parseInt(document.title.split('(')[1], 10);
        let newValue = callback(oldValue);

        document.title = document.title.replace(
            /(.*?)\(\d+\)(.*?)/,
            function (match, prefix, suffix, offset, string) {
                return prefix + '(' + newValue + ')' + suffix;
            }
        );
    }
}

function isEntry() {
    return document.querySelector("section.entry") !== null;
}

function isListView() {
    return document.querySelector(".items") !== null;
}

function findEntry(element) {
    if (isListView()) {
        if (element) {
            return DomHelper.findParent(element, "item");
        } else {
            return document.querySelector(".current-item");
        }
    } else {
        return document.querySelector(".entry");
    }
}

function handleConfirmationMessage(linkElement, callback) {
    if (linkElement.tagName != 'A') {
        linkElement = linkElement.parentNode;
    }

    linkElement.style.display = "none";
    
    let containerElement = linkElement.parentNode;
    let questionElement = document.createElement("span");

    let yesElement = document.createElement("a");
    yesElement.href = "#";
    yesElement.appendChild(document.createTextNode(linkElement.dataset.labelYes));
    yesElement.onclick = (event) => {
        event.preventDefault();

        let loadingElement = document.createElement("span");
        loadingElement.className = "loading";
        loadingElement.appendChild(document.createTextNode(linkElement.dataset.labelLoading));

        questionElement.remove();
        containerElement.appendChild(loadingElement);

        callback(linkElement.dataset.url, linkElement.dataset.redirectUrl);
    };

    let noElement = document.createElement("a");
    noElement.href = "#";
    noElement.appendChild(document.createTextNode(linkElement.dataset.labelNo));
    noElement.onclick = (event) => {
        event.preventDefault();
        linkElement.style.display = "inline";
        questionElement.remove();
    };

    questionElement.className = "confirm";
    questionElement.appendChild(document.createTextNode(linkElement.dataset.labelQuestion + " "));
    questionElement.appendChild(yesElement);
    questionElement.appendChild(document.createTextNode(", "));
    questionElement.appendChild(noElement);

    containerElement.appendChild(questionElement);
}

function toast(msg) {
    if (!msg) return;
    document.querySelector('.toast-wrap .toast-msg').innerHTML = msg;
    let toastWrapper = document.querySelector('.toast-wrap');
    toastWrapper.classList.remove('toastAnimate');
    setTimeout(function () {
        toastWrapper.classList.add('toastAnimate');
    }, 100);
}
class LeftMenu {
    static load() {
        let link = document.querySelector(".left_menu a");
        let request = new RequestBuilder(link.href);
        request.options.method = "GET"
        request.withCallback(function (data){
            data.text().then(function (text) {
                document.getElementsByClassName("left_menu")[0].innerHTML = text;
            });
            if (document.querySelector("body").dataset.leftMenuState === "true") {
                LeftMenu.toggle();
            }
        });
        request.execute();
    }
    static toggle() {
        let menu = document.querySelector("left_menu");
        let main = document.querySelector('main');
        main.classList.toggle("left_menu_main");
        if (!DomHelper.isVisible(menu)) {
            menu.style.display = "block";
            new RequestBuilder(menu.dataset.url + "?status=1").execute();
            if (window.matchMedia("(max-width: 1024px)").matches) {
                main.addEventListener('click', LeftMenu.toggle, false);
            }
        } else {
            menu.style.display = "none";
            new RequestBuilder(menu.dataset.url+ "?status=0").execute();
            main.removeEventListener('click', LeftMenu.toggle, false);
        }
    }
}class ArticleHandler {
    static load(element) {
        let elements = element.querySelectorAll(".article_view_url");
        elements.forEach((element) => {
            let loadingElementWrapper = document.createElement("div");
            loadingElementWrapper.className = "lds-dual-ring-wrapper";
            let loadingElement = document.createElement("div");
            loadingElement.className = "lds-dual-ring";
            loadingElementWrapper.appendChild(loadingElement);
            element.parentNode.appendChild(loadingElementWrapper);

            let request = new RequestBuilder(element.href);

            request.withCallback((data) => {
                data.json().then(function (json) {
                    let view = document.createElement("div");
                    view.className = "entry-content";
                    view.innerHTML = json.content;
                    loadingElementWrapper.remove();
                    element.parentNode.appendChild(view);
                    ArticleHandler.fold(view, element.dataset.labelSeeLess, element.dataset.labelSeeMore);
                    element.remove();
                });
            });

            request.execute();
        });
    }

    static swapTitleLinks() {
        document.querySelectorAll(".item-title a").forEach((element) => {
            if (typeof(element.dataset.altUrl) == "undefined") {
                return;
            }
            var tmpUrl = element.dataset.altUrl;
            element.dataset.altUrl = element.href;
            element.href = tmpUrl;
        });
    }

    static fold(e, lessLabel, moreLabel) {
        var limit = 400;
        if (e.offsetHeight<=limit) {
            return;
        }
        var rbc, ctrl;
        e.style.maxHeight=limit+"px";
        ctrl = document.createElement("div");
        ctrl.classList.add("see-more");
        ctrl.appendChild( document.createTextNode(moreLabel));
        ctrl.addEventListener("click", function () {
            e.style.maxHeight="inherit";
            ctrl.style.display="none";
            rbc.style.display="";
        });
        rbc = document.createElement("div");
        rbc.classList.add("see-more");
        rbc.classList.add("see-less");
        rbc.appendChild( document.createTextNode(lessLabel));
        rbc.addEventListener("click", function () {
            e.style.maxHeight=limit + "px";
            ctrl.style.display="";
            rbc.style.display="none";
        });
        rbc.style.display="none";
        e.parentNode.insertBefore(ctrl, e.nextSibling);
        e.parentNode.insertBefore(rbc, e.nextSibling);
    }
}
/**
 * Trigger event when element appear after scroll
 * Vanilla version of (MIT) https://github.com/morr/jquery.appear/blob/master/index.js
 */
class AppearHandler {
  constructor(selector = "", opts = {}) {
      this.selectors = [
          /* None at the moment */
      ];
      this.checkBinded = false;
      this.checkLock = false;
      this.defaults = {
          interval: 250,
          force_process: false
      };
      this.priorAppeared = [];
      if (selector !== "") {
        this.addSelector(selector, opts);
      }
      this.startMonitorLoop();
  }

  process () {
    this.checkLock = false;


    function isVisible ( element ) {
        return !!( element.offsetWidth || element.offsetHeight || element.getClientRects().length );
    }

    function isAppeared(element) {

        if (!isVisible(element)) {
            return false;
        }

        let windowLeft = window.scrollX;
        let windowTop = window.scrollY;
        let left = element.offsetLeft;
        let top = element.offsetTop;

        let belowTopEdge = top + element.clientHeight >= windowTop;
        let aboveBottomEdge = top  <= windowTop + window.innerHeight;

        let rightAfterLeftEdge = left + element.clientWidth >= windowLeft;
        let leftBeforeRightEdge = left <= windowLeft + window.innerWidth;

        element.dataset.belowTopEdge = belowTopEdge;

        return belowTopEdge && aboveBottomEdge && rightAfterLeftEdge && leftBeforeRightEdge;
    }

    function dispatchAppear(element) {
        element.dispatchEvent(new Event("appear"));
    }

    function dispatchDisapear(element) {
        element.dispatchEvent(new Event("disappear"));
    }
    function arrayIntersect(x, y) {
        return x.filter(e => !y.includes(e));
    }

    for (let index = 0, selectorsLength = this.selectors.length; index < selectorsLength; index++) {
      let appeared = this.selectors[index].filter(isAppeared);

      appeared
        .filter(element => element.dataset._appearTriggered !== "true")
        .map(dispatchAppear);

      if (this.priorAppeared[index]) {
        let disappeared = arrayIntersect(this.priorAppeared[index], appeared);
        disappeared.filter(element => element.dataset._appearTriggered === "true")
            .map(dispatchDisapear);
      }
      this.priorAppeared[index] = appeared;
    }
  }

  addSelector (selector, opts = {}) {
      if (typeof(opts.onappear) === "undefined") {
          opts.onappear = function(e){};
      }
      if (typeof(opts.ondisappear) === "undefined") {
          opts.ondisappear = function(e){};
      }


      let elements = Array.prototype.slice.call(document.querySelectorAll(selector));

      this.priorAppeared.push(elements);
      this.selectors.push(elements);

      elements.map(element => element.addEventListener('appear', function (e) {
          element=e.target;
          element.dataset._appearTriggered = "true";
          opts.onappear(element);
      }));
      elements.map(element => element.addEventListener('disappear', function (e) {
          element=e.target;
          element.dataset._appearTriggered = "false";
          opts.ondisappear(element);
      }));

      this.checkAfterFewSeconds();
  }

  checkAfterFewSeconds() {
      if (this.checkLock) {
          return;
      }
      this.checkLock = true;

      setTimeout(this.process.bind(this), this.defaults.interval);
  }

  startMonitorLoop () {
      if (!this.checkBinded) {
        window.addEventListener('scroll', this.checkAfterFewSeconds.bind(this));
        window.addEventListener('resize', this.checkAfterFewSeconds.bind(this));
        this.checkBinded = true;
      }
    }
}
document.addEventListener("DOMContentLoaded", function () {
    handleSubmitButtons();

    if (!document.querySelector("body[data-disable-keyboard-shortcuts=true]")) {
        let keyboardHandler = new KeyboardHandler();
        keyboardHandler.on("g u", () => goToPage("unread"));
        keyboardHandler.on("g b", () => goToPage("starred"));
        keyboardHandler.on("g h", () => goToPage("history"));
        keyboardHandler.on("g f", () => goToFeedOrFeeds());
        keyboardHandler.on("g c", () => goToPage("categories"));
        keyboardHandler.on("g s", () => goToPage("settings"));
        keyboardHandler.on("ArrowLeft", () => goToPrevious());
        keyboardHandler.on("ArrowRight", () => goToNext());
        keyboardHandler.on("k", () => goToPrevious());
        keyboardHandler.on("p", () => goToPrevious());
        keyboardHandler.on("j", () => goToNext());
        keyboardHandler.on("n", () => goToNext());
        keyboardHandler.on("h", () => goToPage("previous"));
        keyboardHandler.on("l", () => goToPage("next"));
        keyboardHandler.on("o", () => openSelectedItem());
        keyboardHandler.on("v", () => openOriginalLink());
        keyboardHandler.on("V", () => openOriginalLink(true));
        keyboardHandler.on("c", () => openCommentLink());
        keyboardHandler.on("C", () => openCommentLink(true));
        keyboardHandler.on("m", () => handleEntryStatus());
        keyboardHandler.on("A", () => markPageAsRead());
        keyboardHandler.on("s", () => handleSaveEntry());
        keyboardHandler.on("d", () => handleFetchOriginalContent());
        keyboardHandler.on("f", () => handleBookmark());
        keyboardHandler.on("R", () => handleRefreshAllFeeds());
        keyboardHandler.on("?", () => showKeyboardShortcuts());
        keyboardHandler.on("#", () => unsubscribeFromFeed());
        keyboardHandler.on("/", (e) => setFocusToSearchInput(e));
        keyboardHandler.on("Escape", () => ModalHandler.close());
        keyboardHandler.listen();
    }

    let touchHandler = new TouchHandler();
    touchHandler.listen();

    onClick("a[data-save-entry]", (event) => handleSaveEntry(event.target));
    onClick("a[data-toggle-bookmark]", (event) => handleBookmark(event.target));
    onClick("a[data-fetch-content-entry]", () => handleFetchOriginalContent());
    onClick("a[data-action=search]", (event) => setFocusToSearchInput(event));
    onClick("a[data-action=markPageAsRead]", () => handleConfirmationMessage(event.target, () => markPageAsRead()));
    onClick("a[data-toggle-status]", (event) => handleEntryStatus(event.target));


    let appearHandler = new AppearHandler();
    appearHandler.addSelector(
        ".item-status-unread",
        {
            "onappear" : function(element){
                if (document.querySelector("body[data-entry-embedded=true]")) {
                    ArticleHandler.load(element);
                }
            }
        }
    );
    appearHandler.addSelector(
        ".item-header",
        {
            "ondisappear" : function(element) {
                if (! document.querySelector("body[data-auto-mark-as-read=true]")) {
                    return;
                }
                let elementWithStatus = element.parentNode.querySelector("a[data-toggle-status]")
                if (elementWithStatus) {
                    let currentStatus = elementWithStatus.dataset.value;
                    if (element.dataset.belowTopEdge === "false" && currentStatus == "unread") {
                        toggleEntryStatus(element.parentNode);
                    }
                }
            }
        }
    );


    onClick("a[data-confirm]", (event) => handleConfirmationMessage(event.target, (url, redirectURL) => {
        let request = new RequestBuilder(url);

        request.withCallback(() => {
            if (redirectURL) {
                window.location.href = redirectURL;
            } else {
                window.location.reload();
            }
        });

        request.execute();
    }));

    if (document.documentElement.clientWidth < 600) {
        onClick(".logo", () => toggleMainMenu());
        onClick(".header nav li", (event) => onClickMainMenuListItem(event));
    }


    LeftMenu.load()
    onClick(".show_menu", (event) => LeftMenu.toggle());

    if (document.querySelector("body[data-entry-embedded=true]")) {
        ArticleHandler.load();
    }

    onClick(".toggle-entry-embedded", (event) => {
        ArticleHandler.swapTitleLinks();
        if (document.querySelector("body").dataset.entryEmbedded === "true") {
            document.querySelector("body").dataset.entryEmbedded = "false";
            event.target.innerText = event.target.dataset.entryEmbeddedTextOff;
            event.target.setAttribute("title", event.target.dataset.entryEmbeddedTitleOff);
        } else if (document.querySelector("body").dataset.entryEmbedded === "false") {
            document.querySelector("body").dataset.entryEmbedded = "true";
            event.target.innerText = event.target.dataset.entryEmbeddedTextOn;
            event.target.setAttribute("title", event.target.dataset.entryEmbeddedTitleOn);
        }
        return false;
    });


    if ("serviceWorker" in navigator) {
        let scriptElement = document.getElementById("service-worker-script");
        if (scriptElement) {
            navigator.serviceWorker.register(scriptElement.src);
        }
    }

    window.addEventListener('beforeinstallprompt', (e) => {
        // Prevent Chrome 67 and earlier from automatically showing the prompt.
        e.preventDefault();

        let deferredPrompt = e;
        const promptHomeScreen = document.getElementById('prompt-home-screen');
        if (promptHomeScreen) {
            promptHomeScreen.style.display = "block";

            const btnAddToHomeScreen = document.getElementById('btn-add-to-home-screen');
            if (btnAddToHomeScreen) {
                btnAddToHomeScreen.addEventListener('click', (e) => {
                    e.preventDefault();
                    deferredPrompt.prompt();
                    deferredPrompt.userChoice.then(() => {
                        deferredPrompt = null;
                        promptHomeScreen.style.display = "none";
                    });
                });
            }
        }
    });
});
})();`,
	"sw": `'use strict';self.addEventListener("fetch", (event) => {
    if (event.request.url.includes("/feed/icon/")) {
        event.respondWith(
            caches.open("feed_icons").then((cache) => {
                return cache.match(event.request).then((response) => {
                    return response || fetch(event.request).then((response) => {
                        cache.put(event.request, response.clone());
                        return response;
                    });
                });
            })
        );
    }
});
`,
}

var JavascriptsChecksums = map[string]string{
	"app": "7fe6361ce04bd5d59a30c88f814f758fdc7c9e40444d8b35f40eccc239578532",
	"sw":  "74f8138fcb9f13251b777c740575823c1698bddbd16bcd46603929bacdc4064a",
}
